<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Asp.Net Core中间件和路由]]></title>
    <url>%2FAsp.Net%20Core%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[注入日志中间件public void Configure(IApplicationBuilder app,IHostingEnvironment env,IWelcomeService welcomeService,ILogger&lt;Startup&gt; logger) { //Use在启动配置的时候走了一遍，只运行一次 app.Use(next=&gt; { logger.LogInformation(&quot;app.Use()......&quot;);//使用日志 //请求没有拦截的话，请求每次都会运行 return async httpContext=&gt; { logger.LogInformation(&quot;----async httpContext&quot;); if(httpContext.Request.Path.StartsWithSegments(&quot;/first&quot;)) { logger.LogInformation(&quot;----First!!!&quot;); await httpContext.Response.WriteAsync(&quot;First!!!&quot;); } else { logger.LogInformation(&quot;----next(httpContext)&quot;); await next(httpContext);//没有访问first目录，继续往下走 } }; }); app.Run(async(context)=&gt; { var welcome=welcomeService.GetMessage(); await context.Response.WriteAsync(welcome); }); } 使用路由路由分为：1.Convention Route(约定路由) 2.Attribute Route(属性路由),不能混用 约定路由：public void Configure(....) { //创建wwwroot文件夹，新建index.html，使用app.UseFileServer()才能访问 //使用默认路由配置的mvc app.UseStaticFiles(); //app.UseMvcWithDefaultRoute(); //手动配置约定路由 /Home/Index/3 app.useMvc(builder=&gt; { //自定义路由 （名称，模板规则）如果目录没有Home，Index，默认使用Home，Index builder.MapRoute(&quot;Default&quot;,&quot;{controller=Home}/{action=Index}/{id?}&quot;); }); } 访问网站根目录即可到达Index页面 属性路由新建一个AboutController类 //按照路径，先访问控制器名，再访问方法 [Route(&quot;[controller]/[action]&quot;)] public class AboutController { public string Me() { return &quot;Dave&quot;; } public string Company() { return &quot;No Company&quot;; } } /about/me 返回Dave]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Asp.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net Core中的配置和服务注入]]></title>
    <url>%2FAsp.Net%20Core%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Startup类Program里面的CreateWebHostBuilder方法默认使用Startup类。Startup： 可选择性的包含ConfigureServices方法以及配置应用服务 必须包含Configure方法以创建应用的请求处理管道,常见中间件管道顺序： 1.异常/错误处理 2.HTTP严格传输安全协议 3.HTTPS重定向 4.静态文件服务器 5.Cookie策略实施 6.身份验证 7.会话 8.MVC Configure方法使用IApplicationBuilder来使用中间件 有Use，Map，Run三种使用方式： 1.Use使用中间件配置请求管道 2.Map管道分支 3.Run管道短路 Configure方法里注入IConfiguration接口，读取 appsettings.json配置public void Configure(IApplicationBuilder app,IHostingEnvironment env,IConfiguration configuration) { if(env.IsDevelopment()) { app.UseDevelopmerExceptionPage(); } app.Run(async(context)=&gt; { //appsettings.json里面添加的key是Welcome,值为Hello World！ var welcome=configuration[&quot;Welcome&quot;]; await context.Response.WriteAsync(welcome); }); } 运行结果：Hello World！ ConfigureServices配置应用服务public void ConfigureServices(IServiceCollection services) { //服务注入 &lt;接口，实现接口的类&gt; services.AddSingleton&lt;IWelcomeService,WelcomeService&gt;(); //AddSingleton只能有WelcomeService实例 //AddTransient每请求一次方法就创建一个实例 //AddScoped 整个HTTP请求只创建一个实例 } public void Configure(IApplicationBUilder app,IHostingEnvironment env,IWelcomeService welcomeService) { if(env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.Run(async(context)=&gt; { //调用GetMessage方法 var welcome=welcomeService.GetMessage(); await context.Response.WriteAsync(welcome); }); } IWlcomeService接口及实现public interface IWelcomeService { string GetMessage(); } public class WelcomeService:IWelcomeService { public string GetMessage() { return &quot;Hello from IWelcome service!&quot;; } } 运行结果:Hello from IWelcome service!]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Asp.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GtiHub+Hexo搭建个人博客]]></title>
    <url>%2FGtiHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是引用 1,注册GitHub，创建仓库，仓库名：你的GitHub用户名.github.io(必须这种格式) 2,在官网下载，安装git。我们的网站本地搭建好需要用git同步到GitHub上。开始菜单里打开Git here bash，配置信息： git config --global user.name &quot;你的GitHub用户名&quot; (Enter执行) git config --global user.email &quot;你的GitHub注册邮箱&quot; (Enter执行) 本地生成ssh密钥文件（连接Github需要）： ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 然后三个回车，默认不设置密码。 3,然后在.ssh文件夹中用Notepad++ 打开id_rsa.pub密钥，将内容全部复制在GitHub个人下点settings,打开SSH and GPR keys项，新建 new SSH Key：标题随便写，将密钥复制到key新建。 4,在Git Bash中检测公钥是否可用，输入: ssh git@github.com 如果显示成功，这就完成了Git与GitHub绑定 5,安装Node.jsHexo是基于Node.js的,Node.js包含环境变量及npm的安装。 6,安装HexoHexo是博客网站框架。利用npm命令全局安装：npm install -g hexo在电脑上创建一个文件夹，命名myblog，然后鼠标右键文件夹 Git Bash Her安装完后 初始化博客：hexo init安装依赖包： npm install初始化完 检测运行一下：hexo g # 生成(g是generate缩写)hexo s然后再浏览器中打开localhost:4000,就可以打开博客首页 常用的Hexo命令：npm install hexo -g #全局安装Hexonpm update hexo -s #升级hexo init #初始化博客 命令简写：hexo n “文章名” == hexo new “文章名” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启用服务预览hexo d ==hexo deploy #部署本地网页到GitHub hexo server #Hexo会监视文件改变并自动更新，，无需重启服务hexo server -s #静态模式hexo server -p 5000 #改变端口 $ hexo server hexo server -i 192.168.0.1 #自定义IPhexo clean #清楚缓存 7,把Hexo与GitHub关联起来，打开站点配置文件myblog/_config.yml,翻到最后修改为：deploy: type: git #注意空格 ropo: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git branch: master保存站点配置文件 安装Git部署插件：npm install hexo-deployer-git –save完成后执行：hexo cleanhexo ghexo d这样你的网站被部署在GitHub上了，可以网络访问 你的GitHub用户名.github.io 修改文章内链接样式修改文件 themes\next\source\css_common\components\post\post.styl，在末尾添加如下css样式，： // 文章内链接文本样式.post-body p a{ color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; }} 文章添加分类定位到站点目录下: hexo new page categories编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下：title: 分类date: 2014-12-22 12:39:04 type: “categories”在菜单中添加链接。编辑 主题配置文件 ， 添加 categories 到 menu 中，如下:menu: home: / archives: /archives categories: /categories 添加标签在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ：$ cd your-hexo-site$ hexo new page tags编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下：title: 标签date: 2014-12-22 12:39:04 type: “tags”在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下:menu: home: / archives: /archives tags: /tags 百度谷歌收录你的站点 $ npm install hexo-generator-sitemap --save #google npm install hexo-generator-baidu-sitemap --save #百度 添加本地搜索 $ npm install hexo-generator-searchdb --save 站点配置文件，任意位置新增： search: path: search.xml filed: post format: html limit: 10000 编辑主题配置文件，启用搜索: local_serach: enable: true]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>GitGub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数使用]]></title>
    <url>%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[任何一个类至少会有一个构造方法，即使不写，默认会有一个公开的无参构造方法： public class MyClass { //.. } 它的构造方法就是： public Myclass() { //.. } 当我们实例化的时候，其实调用了构造方法。 可以在构造方法上写注释，new时看注释就知道了。 ///&lt;summary&gt; ///这是类 ///&lt;/summary&gt; public class Program { ///&lt;summary&gt; ///这是构造方法 ///&lt;/summary&gt; public Program() { //.. } } 通过有参数构造方法表示必填的字段，防止某些必须的字段时默认值 举个例子，如下实体： public class User { public string FirstName {get;set;} public string LastName {get;set;} public ShowName() { var user=new User(); user.FirstName=&quot;张&quot;; user.LastName=&quot;三&quot;; user.ShowName(); //输出 张三 } } 如果少写一个的话： static void Main(string[] args) { var user=new User(); user.LastName=&quot;三&quot;; user.ShowName(); // 输出 三 } 这就引起不是我们想要的因此构造方法这样就可以避免了: public class User { public User(string firstName,string lastName) { this.FirstName=firstName; tshi.LastName=lastName; } public string FirstName {get; private set;} public string LastName {get; private set;} public string ShowName() { return FirstName+LastName; } } 这里加入了两个参数，姓和名。因此实例化这个对象时必须传入这两个参数。 var user=new User(&quot;张&quot;,&quot;三&quot;); user.ShowName(); //输出 张三 注意：set访问修饰符设置成pbulic属性可以被外面赋值,调用时就会有问题： var user=new User(&quot;张&quot;,&quot;三&quot;); user.FirstName=&quot;李&quot;; user.LastName=&quot;四&quot;; user.ShowName();//输出 李四 本文转载自 http://dotnetstar.club/c/35]]></content>
      <tags>
        <tag>C#</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架与架构设计]]></title>
    <url>%2F%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[test架构：软件体系结构通常称为架构 框架与架构共同点：提高生产效率为了解决问题都是体系化的产物·····不同点：框架是总体规划，协调单元完成工作框架是具体实施内容]]></content>
      <tags>
        <tag>基础</tag>
        <tag>架构</tag>
      </tags>
  </entry>
</search>
