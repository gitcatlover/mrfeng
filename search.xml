<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[4.T-SQL编程]]></title>
    <url>%2F4.T-SQL%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[--申明变量,@@表示的一般是系统变量 --declare @name nvarchar(20) --declare @age int declare @name nvarchar(20),@age int -- 一次申明多个变量 --给变量赋值 set @name=&#39;周星星&#39; select @age=18 --输出 select &#39;姓名&#39;, @name select &#39;年龄&#39;,@age --while循环，跳出循环可以用break;继续循环用continue; declare @i int=1 --声明变量时赋值 declare @sum int=0 while @i&lt;=100 begin set @sum+=@i set @i=@i+1 end select @sum --循环计算1到100的总和 --if else declare @n int=6 if @n&gt;5 begin print&#39;n大于5&#39; end else if @n=5 begin print&#39;n等于5&#39; end else begin print&#39;n小于5&#39; end print @@servername --打印当前服务器名称 --事务,保证两条SQL语句同时成功或失败.ACID特性：原子性，要么全部成功，要么全部失败。一致性，所有数据的完整正确。 --隔离性，事务之间单独存在，互不影响。永久性，事务完成，修改存在系统中，不能回滚. --通过事务转账 begin transaction --打开一个事务,begin tran 也可以 declare @sum int=0 update Bank set balance=balance-10 where cid=&#39;0001&#39; set @sum=@sum+@@error --把SQL语句执行错误编号累加 update Bank set balance=balance+10 where cid=&#39;0002&#39; set @sum+=@@error if(@sum&lt;&gt;0) --只要有任何一条SQL语句错误@sum就不为0 begin rollback --执行错误回滚 end else begin commit --执行正确提交事务 end select *from Bank --自动提交事务，当执行SQL语句时，数据库自动打开一个事务,自动提交，自动回滚 --insert into 等等 --隐式事务,执行SQL语句时，数据库自动打开一个事务，但需要手动提交或回滚 set implicit_transactions{on|off} 隐式事务 set implicit_transactions on --手动打开 insert into Bank values(&#39;0003&#39;,88888) commit --提交,不提交会独占一张表，没办法做其他操作 set implicit_transactions off --手动关闭 --显式事务,需要手动打开事务，手动提交，手动回滚 begin tran.... --存储过程，就像C#里的方法。由存储过程名，存储过程参数组成，可以有返回值。 --优点：执行速度更快，数据中保存的存储过程语句都是编译过的 --允许模块化程序设计，类似方法的复用 --提高系统安全性，防止SQL注入 --减少网络流通量，只是传输存储过程名 --缺点：遇到服务器瓶颈，难以优化 --系统存储过程：存放在master数据库中，以&#39;sp_&#39;或&#39;xp_&#39;开头。 --自定义存储过程：由用户在数据库中创建的存储过程usp，以&#39;usp_开头&#39; print @@servername --返回当前数据库名称 exec sp_databases --返回当前实例中所有数据库基本信息 exec sp_tables --返回当前数据库中所有表 exec sp_columns &#39;Area&#39; --返回Area表中所有的列 exec sp_helptext &#39;sp_databases&#39; --返回&#39;sp_databases&#39;存储过程的源代码 create proc usp_sayhi --这里报错，数据库以为是批量处理所有语句。可以在create前加 go as begin print&#39;HELLO WORLD&#39; end --创建自定义存储过程,修改存储过程把create改为alter create proc usp_add @n1 int,@n2 int as begin print @n1+@n2 end --创建两个带参数的存储过程 exec usp_add 10,50 --调用存储过程 --创建带输出参数的存储过程 create proc usp_class @gender nchar(10),@age int, @recordcount int output --输出参数 as begin select*from Class where ClassGender=@gender and ClassAge&gt;=@age set @recordcount=(select count(*) from Class where ClassGender=@gender and ClassAge&gt;=@age) end declare @n int --创建输出参数 exec usp_class @gender=&#39;女&#39;,@age=18,@recordcount=@n output print @n --打印影响的行数 select*from Class --创建分页查询的存储过程 create proc usp_getClassByPage @pagesize int, --每页记录条数 @pageindex int, --当前要查看的页数 @recordcount int output,@pagecount int output --总记录条数，总共页数 as begin select *from(select*,Rn=row_number() over(order by ClassID asc) from Class) as t where t.Rn between (@pageindex-1)*@pagesize+1 and @pageindex*@pagesize set @recordcount=(select count(*) from Class) --获取总记录条数 set @pagecount=ceiling(@recordcount*1.0/@pagesize) --获得总页数，ceiling 向上取整 end declare @rc int,@pc int exec usp_getClassByPage @pagesize=4,@pageindex=2,@recordcount=@rc output,@pagecount=@pc output print @rc print @pc --执行存储过程 --set与select 赋值的区别 declare @a int --set @a=(select count(*)from Class) print @a select @a=count(*)from Class print @a --set赋值时,当查询语句返回结果不止一个时，直接报错 declare @n int set @n=(select ClassAge from Class) --select 赋值时，当查询语句返回结果不止一个时，把最后的值赋值给变量 declare @n int select @n=ClassAge from Class print @n create proc usp_transfer @from char(20), --转出账号 @to char(20), --转入账号 @money money, --转账金额 @result int output --根据执行结果赋值，输出对应数字 as begin --1,判断余额是否足够转账 declare @sum int=0,@balance money --申明一个余额，判断余额是否足够 set @balance=(select balance from Bank where cid=@from) if(@balance-@money&gt;=10) begin --2,开始转账 begin transaction update Bank set balance=balance-@money where cid=@from set @sum=@sum+@@error update Bank set balance=balance+@money where cid=@to set @sum=@sum+@@error --3,判断执行是否成功，提交或回滚 if(@sum&lt;&gt;0) begin set @result=2 --转账失败 rollback --回滚 end else begin set @result=1 --转账成功 commit --提交事务 end end else begin set @result=3 --用3 值表示余额不足 end end declare @n int exec usp_transfer&#39;0001&#39;,&#39;0002&#39;,620,@result=@n output print @n --SQL里的 try···catch·· begin try update Bank set balance=5 where cid=&#39;0001&#39; --如果出异常，执行 print end try begin catch print&#39;出异常了···&#39; end catch --触发器(trigger) --创建一个触发器 create trigger tri_delete_Class on Class after delete --在执行删除后触发。for,instead of 和after 功能相同 as begin --从临时表deleted 中把数据插入到Class20170104BackUp表中,只有再触发器里能访问 insert into Class20170104BackUp(ClassID,ClassName,ClassGender) select ClassID,ClassName,ClassGender from deleted end select*from Class20170104BackUp select*from Class delete from Class where ClassName=&#39;王八&#39; --数据库锁 --数据库本身有一个查询当前有没有死锁的进程 --避免死锁：1,sql操作表顺序尽量一致 --2,查询时 加 with(nolock),有可能造成脏数据（过期的数据）。适用于安全性要求不高 --链接非常多容易引起死锁（join）,可以创建临时表。让原始表与临时表连接查询创建一个新临时表，再把新临时表与 --原始表连接查询···· --创建Area的临时表，原始表删除，临时表也就不存在了。连接关闭临时表就释放了。## 表示全局临时表 select*into #Area from Area select*from #Area]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.ADO增删查改 登录demo 带参数的sql语句 插入自动返回行号]]></title>
    <url>%2F3.ADO%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%20%E7%99%BB%E5%BD%95demo%20%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84sql%E8%AF%AD%E5%8F%A5%20%E6%8F%92%E5%85%A5%E8%87%AA%E5%8A%A8%E8%BF%94%E5%9B%9E%E8%A1%8C%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[select Name from sysobjects where xtype=&#39;u&#39; order by name --获取选中数据库中所有表 select*from INFORMATION_SCHEMA.TABLES where TABLE_TYPE=&#39;base table&#39; --查询选中数据库中的表信息,不包含视图 select tables.table_name from INFORMATION_SCHEMA.TABLES --查询选中数据库中的表名 select *from INFORMATION_SCHEMA.COLUMNS where COLUMNS.TABLE_NAME=&#39;Area&#39;--查询Area表中列名，数据类型，列顺序等信息 select *from INFORMATION_SCHEMA.COLUMNS where COLUMNS.TABLE_NAME=&#39;Area&#39; select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01 --查询用户创建的所有数据库 SELECT Name FROM Master..SysDatabases ORDER BY Name --查询所有数据库 insert into Class output inserted.ClassID --inserted.ClassName 就返回名字 values(&#39;王er&#39;,&#39;男&#39;,25) -- 插入语句，并返回插入语句的编号 --查询数据,当需要将多个表中列共同显示到一个结果集时,可以用连接查询 select*from PhoneNum inner join PhoneType on PhoneNum.pTypeid=PhoneType.ptid --查询的时候如果表中有重名的列，要在列名前加 表名. select PhoneNum.pTypeid, PhoneNum.pName, PhoneType.ptid from PhoneNum inner join PhoneType on PhoneNum.pTypeid=PhoneType.ptid --还有多个表,后面加join....on... --左外联会将左表中数据全部显示，右表中符合条件的显示，不符合条件的显示null。左表:left outer join 左边的表 select PhoneNum.*, PhoneType.* from PhoneNum left join PhoneType on PhoneNum.pTypeid=PhoneType.ptid --左外联查询 --自连接，自己和自己连接查询 select t2.AreaID 编号, t2.AreaName 城市, t1.AreaName 省份 from Area as t1 inner join Area as t2 on t1.AreaID=t2.AreaPID --自连接城市后面显示省份 --视图，把复杂的SQL语句封装成简单的语句，虚拟表.降低SQL语句复杂度，保证数据安全.视图查询的必须是结果集 create view vw_tblArea as select t2.AreaID 编号, t2.AreaName 城市, t1.AreaName 省份 from Area as t1 inner join Area as t2 on t1.AreaID=t2.AreaPID --创建视图 select *from vw_tblArea --视图查询,里面存储的是SQL语句,一直存在数据库里 select*from vw_tblArea where 编号&gt;10 --视图按条件查询 --case查询 select *, 头衔=case when [level]=1 then &#39;菜鸟&#39; when [level]=2 then &#39;老鸟&#39; else &#39;骨灰&#39; end from [User] --可以区间判断，列名包含关键字要用[] select *, 头衔=case [level] when 1 then &#39;菜鸟&#39; when 2 then &#39;老鸟&#39; else &#39;骨灰&#39; end from [User] select --查询多列显示表里比较大的列 X=case when pid&lt;pTypeid then pTypeid else pid end, Y=case when pCellPhone&lt;pHomePhone then pHomePhone else pCellPhone end from PhoneNum --查询显示球队胜负次数 select 球队名称=TeamName, 胜=sum(case when GameResult=&#39;胜&#39; then 1 else 0 end), 负=sum(case when GameResult=&#39;负&#39; then 1 else 0 end) from BasketBall group by TeamName --先按胜负显示1，0 再按队名分组统计总和 --索引 --索引提高查询效率。分为1,聚集索引(物理),一个表只能有一个聚集索引 --2，非聚集索引（逻辑），一个表中可以有多个非聚集索引 --增加索引会额外增加存储空间，提高增加，删除，修改新纪录的效率 create clustered index IXid on Area(AreaID) --在 AreaID这列创建索引,用到AreaID这列查询，速度就快 drop index Area.IXid --删除索引,创建主键的时候，会自动在主键列创建物理索引 dbcc dropcleanbuffers --清除缓存 --分页查询 select top 3*from Area order by AreaID asc --查询出第一页的数据，每页3条记录 --查询第二页数据。即不在第一页的其他数据前三条 select top 3*from Area where AreaID not in( select top(3*(2-1)) AreaID from Area order by AreaID asc) order by AreaID asc --row_number 分页查询,推荐使用 select*,Rn=row_number() over(order by AreaID asc) from Area --查询时为数据编号,over()编号 select*from( select*,Rn=row_number() over(order by AreaID asc)from Area) as t where t.Rn between (4-1)*3+1 and 4*3 --查询第四页数据，每页显示3条]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.分组 类型转换函数 向表中插入多条数据 字符串函数]]></title>
    <url>%2F2.%E5%88%86%E7%BB%84%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%20%E5%90%91%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[--分组查询 select ClassID 班级ID, 班级人数=count(*) from Class group by ClassID --查询每个班 的ID 和人数 select ClassGender 性别, count(*) 人数 from Class group by ClassGender --查询所有班级 男女人数 select 班级ID=ClassID, --分组后,就不再包含除 group by 外其他列,要查询其他列就要用聚合函数 男生人数=count(*) from Class where ClassGender=&#39;男&#39; group by ClassID --查询所有班级男生人数 --having是对分组后的每一组进行筛选，where 是对分组前每一行筛选 select 班级ID=ClassID, 人数=count(*) from Class group by ClassID having count(*)&gt;1 --分组后 选出人数大于 1 的班级 --数据类型转换 select &#39;100&#39;+cast(&#39;1000&#39; as int) select &#39;100&#39;+convert(int,&#39;1000&#39;) print convert(varchar(200), getdate(),120) --对时间 规范 转换 --使用 union 联合结果集 select*from Class union all select*from one --将两个表中数据联合,联合的列要相同,数据类型要兼容 select ClassName,ClassAge,ClassGender from Class union select name,age,gender from one -- union会去除重复，重新排列数据。union all 不会去除重复，也不会重新排列 --备份数据 backup database TogetherHelp to disk = &#39;C:\Users\小马\backDB\eee.bak&#39; restore database TogetherHelp from disk=&#39;C:\Users\小马\backDB\eee.bak&#39; select* into Class20170104BackUp from Class --把Class 中结构数据 备份到 Class20170104BackUp 中 select top 0*into Class20170104BackUp from Class --创建一个和Class 结构一样的表，不复制数据 insert into Class20170104BackUp --在表格插入数据 select*from Class --数据来自 Class where ClassGender=&#39;女&#39; --所有 ClassGender=&#39;女&#39; 的数据 --常用字符串函数 select len(&#39;H,你好啊&#39;) --5 个字符 print datalength(&#39;H，你好啊&#39;) --9个字节 print datalength(N&#39;H,你好啊&#39;) --10个字节 print &#39;====&#39;+rtrim(+ltrim(&#39; Hi &#39;))+&#39;===&#39; --去掉左右两边空格 print left(&#39;这个世界太疯狂了&#39;,3) -- 从左开始 截取3个字符 print right(&#39;这个世界太疯狂了&#39;,3) --从右开始 截取3个字符 print substring(&#39;这个世界太疯狂了&#39;,1,3) --从第一个字符串开始截取 print substring(&#39;这个世界太疯狂了&#39;,0,3) --从第0个字符串开始截取 print substring(&#39;这个世界太疯狂了&#39;,-2,5) --从第-2个字符串开始截取 --时间函数 select getdate() print sysdatetime() select dateadd(day,365,getdate()) -- 在getdate（） 时间上 在 day 上 增加 365天 select*from Employees where dateadd(year,1,EmpJoinDate)&gt;=getdate() --查询入职一年以上的员工 select datediff(year,&#39;1991-8-8&#39;,getdate()) -- 按照1991-8-8 这个时间计算到现在过了多少年,只是拿年份相减 select 入职年数=datediff(day,EmpJoinDate,getdate())/365, --入职年数 分组 入职人数=count(*) from Employees group by datediff(day,EmpJoinDate,getdate())/365 --查询入职 n 年的员工数 --获取时间的部分值 print datepart(year,getdate()) --获取当前年份 print year(getdate()),年 月 日 都有这种简写 print datepart(month,getdate())]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1，SQL增删改聚合函数]]></title>
    <url>%2F1.SQL%E5%A2%9E%E5%88%A0%E6%94%B9%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[--（Database Management System数据库管理系统）数据库特点：海量存储， -- 查找速度快，并发问题控制，安全性，完整性（数据是真实的） -- MySQL：速度快，适合要求不十分严谨的地方，网页。 -- Primary Key：主键是数据行的唯一标识。主键不能为空，不能重复。一个表中只能有一个主键。 -- 避免数据冗余，可以把表拆分为几个，用外键（Foreign Key）和主键关联起来 -- SQL 常用数据类型 -- 1，image类型 存储byte[] 可以各种文件 -- 2，字符串类型：char nchar varchar nvarchar text ntext varchar(max) nvarchar(max) -- char(2) 表示可以存储两个字节，如ab，长，12 -- nchar(2)表示可以存储两个字符，每个字符占两个字节 -- 当数据库的排序规则不是中文是，存储中文 要用带n 如nchar，nvarchar -- 带 n的类型长度最长可以为8000 不带n 最长可以为 4000 -- 带 var 表示可变长度，如varchar（10） 存储字节不超过10就有几个字节，节省空间，每次写入数据会重新计算分配空间 -- 不带var 表示固定长度，如char（10） 存储一个字节，也会占用10个字节，效率更高 --SQL有5个系统数据库： --1，master：存储所有SQL系统信息，如登录信息，爱她表格信息 --2，msdb：数据库定时执行某些操作 --3，model：创建数据库的模板 --4，tempdb：临时表格存放 --5，Resource（隐藏）：一个只读数据库，文件存放在MSSQL/binn 中 --drop database MyFirstDataBase 删除数据库 --代码创建数据库，新建查询: create database MyFirstDataBase --(不设置参数，就是默认) on primary --配置主数据文件选项 ( name=&quot;MyFirstDataBase&quot;, --逻辑名 filename=&quot;C:\Program Files\Microsoft SQL Server\MSSQL13.SQLSERVER\MSSQL\DATA\MyFirstDataBase.mdf&quot;, --数据文件路径 size=5MB, --初始大小 maxsize=100MB, --最大大小 filegrowth=20% --空间每次增长20% ) log on ( name=&quot;MyFirstDataBase_log&quot;, -- 逻辑名 filename=&quot;C:\Program Files\Microsoft SQL Server\MSSQL13.SQLSERVER\MSSQL\DATA\MyFirstDataBase_log.ldf&quot;, --文件路径 size=5MB ) use MyFirstDataBase --选中要操作的数据库 create table one --创建one表格 (-- 列名 类型 自动编号每次增长1 主键 autoId int identity(1, 1) primary key, name nvarchar(50) not null ) --T-SQL语言 --SQL主要分DDL(定义语言，建表，建库等,如create/drop/alter table等),DML(数据操作语言,如select/insert/update/delete) --DCL(数据库控制语言grant/revoke等) --向表中插入数据 use MyFirstDataBase insert into --插入表格数据，向所有列（除自动编号）添加数据，名 可以省略，值必须与 名 的列顺序一致 Employees(IDCard,EmpName,EmpGender,EmpJoinDate,EmpAge,EmpAddress,EmpPhone,EmpDepartmentID) --自动编号可以省略 values(&#39;421195199808089120&#39;,&#39;花泽香菜&#39;,&#39;false&#39;,&#39;2017-5-5&#39;,16,N&#39;长版第二田&#39;,null,&#39;008&#39;) --中文前N避免因排序规则乱码 select*from Employees -- 查询 --自动编号列默认不插入值，向自动编号插入值： set identity_insert Employees on -- 打开表格自动编号插入 insert into Employees(EmpID,EmpGender,EmpDepartmentID) --插入的列名 values(20,&#39;true&#39;,&#39;9527&#39;) set identity_insert Employees off --关闭表格自动编号插入 --打开关闭 查询结果窗口 ctrl+R insert into Class select&#39;周星星&#39;,20,10,134657879,&#39;男&#39; union all select&#39;周2星&#39;,21,12,134657859,&#39;男&#39; union all select&#39;周3星&#39;,21,12,134657859,&#39;男&#39; --使用 union all 插入多条数据 --update修改语句 --不加where条件，对表中所有修改 update Employees set EmpName=EmpName+&#39;(女)&#39;,Empage=Empage-1 where Empgender=&#39;false&#39; update Employees set EmpName=replace(EmpName,&#39;（女）&#39;,&#39;&#39;) --以空值 代替 带有（女）的名字 select*from Employees --删除语句 delete from Employees where empage&lt;19 --自动编号不会回到初始值 select*from Employees --删除表中全部数据 --1,delete from+表 2,truncate table+表(建议使用),效率高的多,只能全部删除,自动编号恢复初始值,删除数据不触发delete alter table Employees drop column EmpJoinDate --删除表中的列 alter table Employees add EmpJoinDate nvarchar(300) --添加表中列 alter table Employees alter column EmpJoinDate nvarchar(200) --修改表中数据类型 --约束 键名 主键 列名 alter table Employees add constraint PK_Employees_EmpDepartmentID primary key(EmpDepartmentID)--为列增加主键约束 alter table Employees add constraint UQ_Employees_EmpName unique(EmpName) --增加列的唯一键约束 alter table Employees add constraint DF_Employees_EmpGender default(&#39;false&#39;) for EmpGender --增加列的默认约束 alter table Employees add constraint CK_Employees_EmpGender check(EmpGender=&#39;true&#39; or EmpGender=&#39;false&#39;)--增加检查约束 --增加外键约束 alter table Employees add constraint FK_Employees_Departments foreign key(EmpDepartmentID) references Departments(DepartmentID) alter table Employees drop constraint FK_Employees_Departments,CK_Employees_EmpGender --删除多个约束 alter table Employees alter column EmpAge int not null --设置列值不能为空 --创建表格的时候添加约束 create table Class ( ClassNmae nvarchar(20) unique not null, ClassAge int check(ClassAge&gt;=18 and ClassAge&lt;=60), ClassID int primary key, ClassNumber int foreign key references Employees(EmpDepartmentID) ) use MyFirstDataBase create table PassWd(AutoID int identity(1,1), UserName nvarchar(50) not null, constraint UQ_PassWd_UserName unique(UserName), --创建唯一约束 PassWd nvarchar(50) not null) use MyFirstDataBase drop table PassWd --查询语句 select*from Employees --查询表所有内容 select EmpName,EmpAge,EmpPhone from Employees -- 查询部分列 select*from Employees where EmpID=2 --按条件查询 select*from Employees where EmpID&lt;&gt;2 --查询EmpID 不等于 2 的数据 select EmpID &#39;(员工编号)&#39;, EmpName as 员工姓名, --as 可以省略 员工年龄=EmpAge, 婚否=&#39;否&#39; --给查询表中没有的列加上 列名 值 from Employees --为查询结果的列取别名，并不改变数据库内容 select 系统当前时间= getdate() --获取当前时间 select 班级=&#39;三班&#39;, 班长=&#39;莉亚&#39; select distinct EmpID,EmpPhone from Employees --查询结果去除重复数据 select*from Employees order by EmpAge desc --查询结果降序排列 select*from Employees order by EmpAge asc --查询结果升序排列 asc可以省略 select top 5*from Employees order by EmpAge desc --查询结果降序排列,获得前5个 select top 30 percent *from Employees order by EmpAge --查询结果升序排列,获得前30% select*from Class order by ClassID desc,ClassNumber desc --查询ClassID，ClassNumber综合降序排名 select*, 平均=(ClassID+ClassNumber)*1.0/2 from Class order by 平均 desc --查询所有，显示平均 --聚合函数,不统计空值 select count(*) 所有列数 from Employees --获得所有列数 select sum(EmpAge) 年龄总和 from Employees --获得 年龄总和 select avg(EmpAge*1.0) 平均值 from Employees -- 获得平均值 select max(EmpAge) 最大年龄 from Employees --获取表中年龄最大值 select min(EmpAge) 最小年龄 from Employees --获取表中年龄最小值 select*from Employees where EmpAge=19 or EmpAge=20 select*from Employees where EmpAge in(19,20) --这是上面查询简写形式 select*from Employees where EmpAge&gt;=19 and EmpAge&lt;=22 --连续几个数字 最好这种写法效率高 --模糊查询,只查询字符串,[,],^,%,_ 通配符 select*from Employees where EmpName like &#39;张%&#39; and len(EmpName)=2 select*from Employees where EmpName like &#39;张_&#39; --查询姓 张 两个字的名字 select*from Employees where EmpName like &#39;张%&#39; --查询姓 张 的所有名字 select*from Employees where EmpName like &#39;张[0-9]妹&#39; --如果中间数字式 9 以外查不出 select*from Employees where EmpName like &#39;张[^0-9]妹&#39; --查询姓 张,中间不是数字,结尾是 妹 的名字 select*from EMployees where EmpName like &#39;张[a-z]妹&#39; --查询姓 张 中间是字母（默认不区分大小写），结尾是 妹 的名字 select*from Employees where EmpName like &#39;张[0-9a-z]妹&#39; select*from Employees where EmpName like &#39;%[%]%&#39; -- 查询出所有 中间是 % 的名字. 加[]转义 select*from Employees where EmpName like &#39;%/[%&#39; escape &#39;/&#39; --查询带有 [ 的名字,自己指定 &#39;/&#39;是转义符 select*from Employees where EmpName like &#39;%/[%/]%&#39; escape &#39;/&#39; --查询带 [] 的名字 select*from Employees where EmpName is not null --查询所有不是 null 的名字]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mvc自定义Filter]]></title>
    <url>%2FMvc%E8%87%AA%E5%AE%9A%E4%B9%89Filter%2F</url>
    <content type="text"><![CDATA[授权特性public class NeedLoginAttribute : AuthorizeAttribute { public override void OnAuthorization(AuthorizationContext filterContext) { if(IsLogin) { filterContext.Result = new RedirectResult(&quot;/Home/Login&quot;); //把登陆前想访问的网址添加到cookie string url=filterContext.HttpContext.Request.Url.ParthAndQuery; filterContext.HttpContext.Response.Cookies.Add(new HttpCookie(&quot;cookie_url&quot;),url); } } } 在&quot;/Home/Login&quot;方法里获取url,然后重定向url 自定义ModelState验证特性public class ValidationAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext filterContext) { ViewDataDirectionary viewData = filterContext.Controller.ViewData; if(!viewData.ModelState.IsValid) { filterContext.Controller.TempData[&quot;error_data&quot;] = viewData.ModelState; filterContext.Result = new RedirectToRouteResult(filterContext.RouteData.Values); } base.OnActionExecuting(filterContext); } } 验证错误信息重定向时需要返回: public class ImportModeStateAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext filterContext) { filterContext.Controller.ViewData.ModelState.Merg( (ModelStateDictionary)(filterContext.Controller.TempData[&quot;error_data&quot;])); base.OnActionExecuting(filterContext); } }]]></content>
      <categories>
        <category>Asp.Net Mvc</category>
      </categories>
      <tags>
        <tag>Asp.Net Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core IP 请求频率限制]]></title>
    <url>%2FASP.NET%20Core%20IP%20%E8%AF%B7%E6%B1%82%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[限制IP请求频率 NuGet安装AspNetCoreRateLimit 修改Startup.cs public void ConfigureServices(IServiceCollection services) { // 需要从appsettings.json中加载配置 services.AddOptions(); // 存储IP计数器及配置规则 services.AddMemoryCache(); services.Configure&lt;IpRateLimitOptions&gt;(Configuration.GetSection(&quot;IpRateLimiting&quot;)); services.AddSingleton&lt;IIpPolicyStore, MemoryCacheIpPolicyStore&gt;(); services.AddSingleton&lt;IRateLimitCounterStore, MemoryCacheRateLimitCounterStore&gt;(); // 按照文档，这两个是3.x版的breaking change，要加上 services.AddSingleton&lt;IHttpContextAccessor, HttpContextAccessor&gt;(); services.AddSingleton&lt;IRateLimitConfiguration, RateLimitConfiguration&gt;(); } 使用频率限制 public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // 注意顺序，放在 UseMvc 上面 app.UseIpRateLimiting(); app.UseMvc(); } 设置要限制的url [Route(&quot;/fw/{token}&quot;)] public async Task&lt;IActionResult&gt; Forward(string token) 在 appsettings.json 里加入 &quot;IpRateLimiting&quot;: { &quot;EnableEndpointRateLimiting&quot;: true, //IP限制会应用于单个配置的Endpoint上。如果是false的话，只会限制所有 * 的规则，而不能达到针对单个Endpoint配置的目的 &quot;StackBlockedRequests&quot;: false, &quot;RealIpHeader&quot;: &quot;X-Real-IP&quot;, &quot;ClientIdHeader&quot;: &quot;X-ClientId&quot;, &quot;HttpStatusCode&quot;: 429,//触发限制之后给客户端返回的HTTP状态码 &quot;GeneralRules&quot;: [ {//*: 表示任何HTTP VERB，如GET/POST，而结尾的 /* 表示需要考虑/fw后面的参数，也就是我MVC Action参数里的route参数。针对不同token，会有不同的计数 &quot;Endpoint&quot;: &quot;*:/fw/*&quot;, &quot;Period&quot;: &quot;1m&quot;, &quot;Limit&quot;: 2 } ] } 还有针对Client ID而不是IP做限制、白名单、分布式计数器存储、自定义返回内容等等]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Asp.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#新特性]]></title>
    <url>%2F11%E7%89%88%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1.Func&lt;int,int,int&gt; add = (x,y) =&gt; x + y; ==&gt; int add(int x,int y) =&gt;x + y; 2.object a = 5; if(a is int number) { Console.WriteLine(number);//5 } 3.只读属性: public string FullName =&gt; $&quot;{FirstName} {LastName}&quot;; 终止某个任务CancellationTokenSource source = new CancellationTokenSource(); CancellationToken token = source.Token; Task&lt;DateTime&gt; getup = Task&lt;DateTime&gt;.Run(() =&gt; //getup已经Run()起来了 { token.ThrowIfCancellationRequested(); //如果被cancel()，抛出异常 Console.WriteLine($&quot;Task-{Task.CurrentId}：起床啦！....&quot; + $&quot;ThreadId:{Thread.CurrentThread.ManagedThreadId}&quot;); return DateTime.Now; }, token); //传入token指令，确保cancel通知能够被侦听 source.Cancel(); //使用source进行cancel try { getup.Wait(); //只有在Wait()时才能捕获异常 } catch (AggregateException ae) { //使用Handle()方法进行处理 ae.Handle((e) =&gt; { Console.WriteLine(&quot;canceled?&quot;); return true; //表示已经成功处理，不需要再抛出异常 }); } static void Foo(StringBuilder sbb /* string sbb*/) { sbb.Append(&quot;test&quot;); sbb = null; } StringBuilder sb = new StringBuilder(); Foo(sb);//test win+D 显示桌面 win+S 搜索 win+E 打开文件夹 win+I 设置 win+L 锁定屏幕 win+; Emoji输入框 win+shift+s 截屏 win+ctrl+D 建虚拟桌面 并行Linq仅适用于Linq to Object ,对数据源进行分区 try { IEnumerable&lt;int&gt; numbers = Enumerable.Range(0,1000); var filtered = numbers.AsParallel() .Where(n=&gt; n%5 == 0); filtered.ForAll(f=&gt;Console.WriteLine(f)); } catch(AggregateException ex) { foreach (var item in ex.InnerExceptions) { Console.WriteLine(item.Message); } }]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令]]></title>
    <url>%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[CMDsc 是用来与服务控制管理器和服务进行通信 dir 显示当前目录中的文件 dir /? 查看dir帮助 set 查看所有环境变量 cd .. 返回上一级目录 type nul &gt; test.txt 创建test.txt空文件 del file_name 删除文件 notepad test.txt 打开test.txt type test.txt 读取test.txt echo &gt; test.txt echo打开 写入test.txt(没有文件就创建) rd/s/q 盘符:\某个文件夹 （强制删除文件文件夹和文件夹内所有文件） del/f/s/q 盘符:\文件名 （强制删除文件，文件名必须加文件后缀名） net user 查看本机账户情况 net share 查看共享资源 net share delname/delete 删除共享文件夹 nslookup github.com 查看github服务器ip netsh wlan show profile wifiname key=clear 查看已连接的wifi信息 gitgit init 在当前目录初始化一个仓库 git remote show 查看仓库名 git remote rename oldName newName 改为newName git add test.txt 把当前目录中test.txt添加到本地git仓库(git add . 添加所有) git status 查看仓库中文件状态 git commit -m &quot;描述信息&quot; -a 提交所有已更改的commit文件 git commit test.txt --amend 把文件提交的最近2条日志覆盖为最新的一条 git diff test.txt 在仓库目录,test.txt已提交和暂存区的差异 git commit --amend 修改最近一次的commit描述 git rebase -i HEAD~3 修改commit倒数第三条 修改后执行 git rebase --continue git push -f git log 查看提交日志(返回324b7...是提交的版本号) git log -2 -p 最新的2条更新及改动详情 git log --since=2.weeks 最近两周以内的提交 git log test.txt 查看test.txt更新日志 git log --pretty=oneline 在一行上精简显示日志 git rm test.txt 仓库和本地都删除 git rm --cached test.txt 从已提交移除,变为untrack del test.txt 删除test.txt git reset HEAD test.txt 从仓库撤销到暂存区 git checkout -- test.txt 让这个文件回到最近一次git commit或git add时的状态 git reset --hard 324b7 根据日志号前几位回滚 git reflog 回滚后,查看命令历史,以便回到未来 git remote -v 查看当前配置的远程仓库 git remote rename test.txt new.txt test改名为new git ls-files 查看仓库中已提交文件 git mv test.txt testNew.txt 改名为testNew.txt git tag v0.1 3d2342 按照版本号打标签 git tag -d v0.1 按版本号删除 git show v0.1 按标签号查看提交信息 git checkout v0.1 按标签号回滚,日志也回滚 git reset --hard b65bb6f 按照日志号回滚到未来或过去 配置gitssh-keygen -t rsa -C &quot;github上注册的邮箱&quot; 创建本地ssh key ssh -T git@github.com 验证是否配置成功 git config --global user.name &quot;github用户名&quot; git config --global user.email &quot;注册github的邮箱&quot; git config --list 查看git已有配置信息 提交到GitHubgit clone url 从远程克隆仓库到当前目录 git push 自己取的仓库名 v0.1 推送标签到远程仓库 git push -u origin master 第一次推送到远程仓库origin的master分支 git fetch 获取远程仓库里（别人提交的）未同步的更新信息，并存放到本地仓库 git merge 将fetch得到的更新同步到工作区（分支合并） git pull 等价于 fetch + merge git config receive.denyCurrentBranch ignore 本地克隆push报错denyCurrentBranch,在远程设置接收配置 git push origin feature 推送到远程origin,如果没有feature就远程创建 分支 git init --bare 创建裸仓库(远程端) git remote add dev url 在url上创建远程仓库dev git checkout -b rel 强制创建rel分支 本地磁盘提交1,初始化两个文件夹sample,remote 2,两文件夹:git init 3,sample里创建文件并commit 4,添加远程仓库:git remote add origin c:\..\remote 5,remote路径下:git config receive.dencyCurrentBranch ignore 6,sample推送:git push origin master 推送到GitHub1,在GitHub上创建仓库,ignore选Visual Studio,添加readme. 2,本地:git clone git@github.com:username/sample.git 3,本地commit后:git push origin master (远程默认名origin)]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xUnit.NET对.NET Core单元测试]]></title>
    <url>%2FxUnit.NET%E5%AF%B9.NET%20Core%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[为什么要自动化测试 可以频繁进行测试 可以在任何时间测试,也可以按计划进行 比人工测试快,更快发现错误 非常可靠,测试代码与生产代码紧密结合 使得开发团队更具幸福感]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Asp.Net Core</tag>
        <tag>xUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存&数据压缩&token]]></title>
    <url>%2F%E7%BC%93%E5%AD%98%26%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%26token%2F</url>
    <content type="text"><![CDATA[客户端Response缓存： 基于Header 客户端缓存 使用ResponseCache这个Attribute 在 Startup 里设置: services.AddMvc(options=&gt; { options.CacheProfiles.Add(&quot;Default&quot;,new CacheProfile { Duration=30//30秒后缓存过期 }); }); 在Controller使用： //缓存保存时间30秒，保存位置在客户端。前进后退可用，刷新重新请求 //[ResponseCache(Duration=30,Location=ResponseCacheLocation.Client)] [ResponseCache(CacheProfileName=&quot;Default&quot;)] public IActionResult Index() { return View(); } 服务器端缓存:Startup里: services.AddMemoryCache(); 使用： 1. 新建一个类，存储缓存的key： public class CacheEntryConstants { //声明一个缓存的key ：AlbumsOfDay，值是它的字符串 public const string AlbumOfDay = nameof(AlbumOfDay); } 2. private readonly IMermoryCache _memoryCache; private readonly IAlbumService _albumService; private readonly HtmlEncoder _htmlEncoder;//防御xss恶意代码 public AlbumController(IMermoryCache memoryCache,IAlbumService albumService,HtmlEncoder htmlEncoder) { this._memoryCache = memoryCache; this._albumService = albumService; this._htmlEncoder = htmlEncoder; } 3.缓存Album这个页面: public async Task&lt;IActionResult&gt; Index() { //参数（缓存的key，缓存的值） if(!_memoryCache.TryGetValue(CacheEntryConstants.AlbumsOfDay, out LIst&lt;Album&gt; cacheAlbums)) { //缓存为空，获取值放入缓存 cacheAlbums = await _albumService.GetAll(); var cacheEntryOptions = new MemoryCacheEntryOptions() //在20秒内获取缓存值，过期时间延后20秒 .SetSlidingExpiration(TimeSpan.FromSeconds(20)); //缓存20秒就过期 //.SetAbsoluteExpiration(TimeSpan.FromSeconds(20)); //设置缓存的值 _memoryCache.Set(CacheEntryConstants.AlbumsOfDay, cacheAlbums, cacheEntryOptions); } return View(cacheAlbums); } 为提交数据做处理：public async Task&lt;IActionResult&gt; Create() { var new Model = await _albumService.AddAsync(new Album { //为提交的数据做处理 Artist = _htmlEncoder.Encode(albumCreateViewModel.Artist), ........ }) } 使用数据压缩功能:添加服务： services.AddResponseCompression(); 使用： app.UseReponseCompression(); Token防跨站伪造：//为所有post添加token标签 services.AddMvc(opt=&gt; { //在不需要token的post上添加 [IgnoreAntiforgeryToken] opt.Filters.Add(new AutoValidateAntiforgeryTokenAttribute()); }); //单个方法添加token： [ValidateAntiForgeryToken] ef mvc使用缓存1,在要缓存的页面Action上:[OutputCache(Duration = 60, VaryByParam = &quot;*&quot;)]//缓存60秒,任意参数改变,缓存就改变 2,在有部分页的主页使用了缓存,子页面也会缓存,这时要使用MvcDonutCaching包,在主页方法上[DonutOutputCache].]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Asp.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志&Model验证]]></title>
    <url>%2F%E6%97%A5%E5%BF%97%26Model%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[第三方日志Serilog.AspNetCore1. NuGet安装Serilog.AspNetCore，Serilog.Sinks.Console(调试控制台显示日志),Serilog.Sinks.File 2. Main方法里： Log.Logger = new LoggerConfiguration() .MinimumLevel.Debug()//最下级别Debug //遇到Microsoft命名空间最低级别Information .MinimumLevel.Override(&quot;Microsoft&quot;,LogEventLevel.Information) .Enrich.FromLogContext()//通过上下文可以记录其他信息 .WriteTo.Console() //日志文件创建在logs文件夹里，每天一个 .WriteTo.File(Path.Combine(&quot;logs&quot;,&quot;log.txt&quot;),rollingInterval:RollingInterval.Day) .CreateLogger(); 使用： public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseSerilog()//使用日志 .UseStartup&lt;Startup&gt;(); Model验证1. 写一个验证已存在角色方法： [AcceptVerbs(&quot;Get&quot;,&quot;Post&quot;)]//接受get，post请求 public async Task&lt;IActionResult&gt; CheckRoleExit([Bind(&quot;RoleName&quot;)] string roleName) {//Bind 只接收View传过来的RoleName var role = await _roleManager.FindByNameAsync(roleName); if(role!=null) { return Json(&quot;角色已存在！&quot;);//return Json(false); //返回ErrorMessage里的值 } return Json(true); } 2. Remote在前台直接调用CheckRoleExist方法验证角色是否存在 在添加角色的RoleAddViewModel里： [Remote(nameof(RoleController.CheckRoleExit),&quot;Role&quot;,ErrorMessage = &quot;角色存在&quot;)] public string RoleName{get;set;} 3. 在AddRole页面： @model MyWeb.ViewModels.RoleAddViewModel &lt;form method=&quot;post&quot;&gt; &lt;input class = &quot;form-control&quot; asp-for=&quot;RoleName&quot;/&gt; &lt;span class = &quot;invalid&quot; asp-validation-for=&quot;RoleName&quot;&gt;&lt;/span&gt; 在没有提交刷新情况下会验证角色是否已存在]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Asp.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[C#基础：mian方法可以返回int，通常是0，不是0，就发生了错误 var b = 0b1001;//前面加上0b二进制 var a = 0x4F;//16进制 Console.WriteLine(1.0 / 0.0);//∞ Console.WriteLine(-1.0 / 0.00);// -∞ Console.WriteLine(1.0/-0.00);//-∞ Console.WriteLine(-1.0/-0.0);//∞ //NaN 和 NaN不相等，使用Object.Equal()时相等。 Console.WriteLine(0.0/0.0);//NaN Console.WriteLine((1.0/0.0)-(1.0/0.0));//NaN Console.WriteLine((0.0/0.0)==double.NaN);//false Console.WriteLine(object.Equals((0.0/0.0),double.NaN));//true //double 特殊值：+0,-0,∞,-∞,NaN const 和 static readonly区别： const（静态常量）:在编译期间解析的常量必须声明就初始化(int,float,枚举,字符串。不能new)可修饰类中成员，也可修饰函数体内局部变量 static readonly（动态常量）:在运行期间解析的常量可在声明时初始化，也可在构造器中初始化只修饰类中成员 去掉集合里的重复数据int[] a={1,2,3,3,,5,5,7,3,1,4}; HasSet&lt;int&gt; hs = new HasSet&lt;int&gt;(a); foreach(var item in hs) { Console.WriteLine(item+ &quot; &quot;); } //无限循环 for(; ;) { } 空接合操作符x??y??z 如果之前所有表达式为空，就选择最后一个 continue语句bool insideDomain=false; Console.WriteLine(&quot;Enter an email address:&quot;); string email=Console.ReadLine(); Console.Write(&quot;The email domain is:&quot;); foreach(char letter in email) { if(!insideDomain) { if(letter==&#39;@&#39;) { insideDomain=true; } continue; } Console.Write(letter); } 泛型Student:PersonPerson s = new Person();s = new Student();Person p = new Person();p = new Person();//报错,泛型模板不同typeof(T);//编译时运行,可以获取T数据类型.Gettype();//运行时执行default(T);//泛型默认值 网络基本系列将数据流分割多路传输,传输形式称为协议数据单元(PDU)网关:主机发送消息到远端网络,必须使用路由器,也称默认网关.mac地址:是生产厂商烧制录好的,物理地址,一般不能改,更换网卡后就改变. getmac或ipconfig /all Server=(localdb)\mssqllocaldb;Database=CoreMoivie;Trusted_Connection=True;MultipleActiveResultSets=true var a=new [] {&#39;a&#39;,&#39;c&#39;,&#39;d&#39;,2};//var是int类型,字符可以隐式转换为无符号short整型 静态字段存放在堆上,会存活到应用程序域停止 变量和方法存放在栈上 char类型默认值 &#39;/0&#39; 方法,构造函数,索引器都可以申明可选参数]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GtiHub+Hexo搭建个人博客]]></title>
    <url>%2FGtiHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是引用 1,注册GitHub，创建仓库，仓库名：你的GitHub用户名.github.io(必须这种格式) 2,在官网下载，安装git。我们的网站本地搭建好需要用git同步到GitHub上。开始菜单里打开Git here bash，配置信息： git config --global user.name &quot;你的GitHub用户名&quot; (Enter执行) git config --global user.email &quot;你的GitHub注册邮箱&quot; (Enter执行) 本地生成ssh密钥文件（连接Github需要）： ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 然后三个回车，默认不设置密码。 3,然后在.ssh文件夹中用Notepad++ 打开id_rsa.pub密钥，将内容全部复制在GitHub个人下点settings,打开SSH and GPR keys项，新建 new SSH Key：标题随便写，将密钥复制到key新建。 4,在Git Bash中检测公钥是否可用，输入: ssh git@github.com 如果显示成功，这就完成了Git与GitHub绑定 5,安装Node.jsHexo是基于Node.js的,Node.js包含环境变量及npm的安装。 6,安装HexoHexo是博客网站框架。利用npm命令全局安装：npm install -g hexo在电脑上创建一个文件夹，命名myblog，然后鼠标右键文件夹 Git Bash Her安装完后 初始化博客：hexo init安装依赖包： npm install初始化完 检测运行一下：hexo g # 生成(g是generate缩写)hexo s然后再浏览器中打开localhost:4000,就可以打开博客首页 常用的Hexo命令：npm install hexo -g #全局安装Hexonpm update hexo -s #升级hexo init #初始化博客 命令简写：hexo n “文章名” == hexo new “文章名” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启用服务预览hexo d ==hexo deploy #部署本地网页到GitHub hexo server #Hexo会监视文件改变并自动更新，，无需重启服务hexo server -s #静态模式hexo server -p 5000 #改变端口 $ hexo server hexo server -i 192.168.0.1 #自定义IPhexo clean #清楚缓存 7,把Hexo与GitHub关联起来，打开站点配置文件myblog/_config.yml,翻到最后修改为：deploy: type: git #注意空格 ropo: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git branch: master保存站点配置文件 安装Git部署插件：npm install hexo-deployer-git –save完成后执行：hexo cleanhexo ghexo d这样你的网站被部署在GitHub上了，可以网络访问 你的GitHub用户名.github.io 修改文章内链接样式修改文件 themes\next\source\css_common\components\post\post.styl，在末尾添加如下css样式，： // 文章内链接文本样式.post-body p a{ color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; }} 文章添加分类定位到站点目录下: hexo new page categories编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下：title: 分类date: 2014-12-22 12:39:04 type: “categories”在菜单中添加链接。编辑 主题配置文件 ， 添加 categories 到 menu 中，如下:menu: home: / archives: /archives categories: /categories 添加标签在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ：$ cd your-hexo-site$ hexo new page tags编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下：title: 标签date: 2014-12-22 12:39:04 type: “tags”在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下:menu: home: / archives: /archives tags: /tags 百度谷歌收录你的站点 $ npm install hexo-generator-sitemap --save #google npm install hexo-generator-baidu-sitemap --save #百度 添加本地搜索 $ npm install hexo-generator-searchdb --save 站点配置文件，任意位置新增： search: path: search.xml filed: post format: html limit: 10000 编辑主题配置文件，启用搜索: local_serach: enable: true]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>GitGub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EFCore基础]]></title>
    <url>%2FEFCore%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[种子数据库//查看EFCore命令：get-help entityframeworkcore//script-migration 生成sql脚本 //Model里有一个省份Province，一个城市City //在 DBContex 里： protected override void OnModelCreating(ModelBuilder modelBuilder) { //添加了一个省份的种子，Id是自增的 modelBuilder.Entity&lt;Province&gt;().HasData( new Province { Id = 1, Name=&quot;广东&quot;, Populiation=70000000 }); } 生成迁移： Add-Migration xxx 获取客户端IP地址在Startup.cs里： services.AddHttpContextAccessor(); service.TryAddSingleton&lt;IActionContextAccessor,ActionContextAccessor&gt;(); 在MVC视图里： @inject Microsoft.AspNetCore.Http.IHttpContextAccessor HttpContextAccessor 使用方法： Client IP: @HttpContextAccessor.HttpContext.Connection.RemoteIpAddress.ToString() Session 和 Cookie1. 手动添加Session支持： services.AddDistributedMemoryCache(); services.AddSession(options=&gt; { options.IdleTimeOut = TimeSpan.FromMinutes(20); options.Cookie.HttpOnly = true; }); 2. app.UseSession(); 3. 设定和获取Session值： HttpContest.Session.SetString(&quot;CaptchaCode&quot;,resultCaptchaCode); HttpContext.Session.GetString(&quot;CaptchaCode&quot;); 清除值： context.Session.Remove(&quot;CaptchaCode&quot;);]]></content>
      <categories>
        <category>ASP.NetCore</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Controller返回View]]></title>
    <url>%2FController%E8%BF%94%E5%9B%9EView%2F</url>
    <content type="text"><![CDATA[IActionResult控制器里面： public IActionResult Index() { //IActionResult决定返回字符串，mvc框架会在管道某处返回结果 //Action里决定要做什么事，做事的是mvc框架 return Content(&quot;Hello!!!&quot;); } public string Index() { return &quot;Hello!!!&quot;;//会直接返回字符串 } 返回View视图1,新建一个Student类，里面有Id,FirstName,LastName。为了让数据与Controller无关，建一个Services文件夹，建一个接口： public interface IRepository&lt;T&gt; where T:class { //返回集合，这里用IEnumerable&lt;T&gt; IEnumerablbe&lt;T&gt; GetAll(); } 2,Services文件夹里建一个InMemoryRepository类，继承IRpository&lt;T&gt;： public class InMemoryRepository:IRepository&lt;Student&gt; { public Ienmuerable&lt;Student&gt; Getall() { return new List&lt;Student&gt;() { new Student{Id=2,FirstName=&quot;Nick&quot;,LastName=&quot;Carter&quot;}, new Student{Id=3,FirstName=&quot;Aick&quot;,LastName=&quot;Farter&quot;} }; } } 3,在Startup类ConfigureServices里注入服务： services.AddScoped&lt;IRepository&lt;Student&gt;,InMemoryRepository&gt;(); Configure里配置路由： app.UseMvc(builder=&gt; { builder.MapRoute(&quot;Default&quot;,&quot;{controller=Home}/{action=Index}/{id?}&quot;); }); 4,HomeController里调用服务，在构造函数里注入: private readonly IRepository&lt;Student&gt; _repository;//只读字段 //鼠标移动到repository参数上，Ctrl+.快捷生成自读字段 public HomeController(IRepository&lt;Student&gt; repository) { this._repository=repository; } public IActionResult Index() { var student=_repository.GetAll(); return View(student); } 运行返回student列表 Model里的字段不需要都展示在View上，可以建ViewModelpublic class StudentViewModel { public int Id{get;set;} public string Name{get;set;} public int Age{get;set;} } public class HomeIndexViewModel { //就一个属性，是student列表集合 public Ienumerable&lt;StudentViewModel&gt; students{get;set;} } //HomeController public IActionResult Index() { var student=_repository.GetAll(); var vms=student.Select(x=&gt;new StudentViewModel() { Name=$&quot;{x.FirstName} {x.LastName}&quot;, Age=DateTime.Now.Subtract(x.BirthDate).Days/365 }); var vm=new HomeIndexViewModel() { students=vms }; return view(vm); } //视图中以前用 @Html.ActionLink() //Core中在View文件夹添加 _ViewImports.cshtml 视图导入页: //@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers //引用Tag Helpers： &lt;a asp-action=&quot;Detial&quot; asp-route-id=&quot;@s.Id&quot;&gt;id是需要的参数&lt;/a&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Asp.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net Core中间件和路由]]></title>
    <url>%2FAsp.Net%20Core%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[注入日志中间件public void Configure(IApplicationBuilder app,IHostingEnvironment env,IWelcomeService welcomeService,ILogger&lt;Startup&gt; logger) { //Use在启动配置的时候走了一遍，只运行一次 app.Use(next=&gt; { logger.LogInformation(&quot;app.Use()......&quot;);//使用日志 //请求没有拦截的话，请求每次都会运行 return async httpContext=&gt; { logger.LogInformation(&quot;----async httpContext&quot;); if(httpContext.Request.Path.StartsWithSegments(&quot;/first&quot;)) { logger.LogInformation(&quot;----First!!!&quot;); await httpContext.Response.WriteAsync(&quot;First!!!&quot;); } else { logger.LogInformation(&quot;----next(httpContext)&quot;); await next(httpContext);//没有访问first目录，继续往下走 } }; }); app.Run(async(context)=&gt; { var welcome=welcomeService.GetMessage(); await context.Response.WriteAsync(welcome); }); } 使用路由路由分为：1.Convention Route(约定路由) 2.Attribute Route(属性路由),不能混用 约定路由：public void Configure(....) { //创建wwwroot文件夹，新建index.html，使用app.UseFileServer()才能访问 //使用默认路由配置的mvc app.UseStaticFiles(); //app.UseMvcWithDefaultRoute(); //手动配置约定路由 /Home/Index/3 app.useMvc(builder=&gt; { //自定义路由 （名称，模板规则）如果目录没有Home，Index，默认使用Home，Index builder.MapRoute(&quot;Default&quot;,&quot;{controller=Home}/{action=Index}/{id?}&quot;); }); } 访问网站根目录即可到达Index页面 属性路由新建一个AboutController类 //按照路径，先访问控制器名，再访问方法 [Route(&quot;[controller]/[action]&quot;)] public class AboutController { public string Me() { return &quot;Dave&quot;; } public string Company() { return &quot;No Company&quot;; } } /about/me 返回Dave]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Asp.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net Core中的配置和服务注入]]></title>
    <url>%2FAsp.Net%20Core%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Startup类Program里面的CreateWebHostBuilder方法默认使用Startup类。Startup： 可选择性的包含ConfigureServices方法以及配置应用服务 必须包含Configure方法以创建应用的请求处理管道,常见中间件管道顺序： 1.异常/错误处理 2.HTTP严格传输安全协议 3.HTTPS重定向 4.静态文件服务器 5.Cookie策略实施 6.身份验证 7.会话 8.MVC Configure方法使用IApplicationBuilder来使用中间件 有Use，Map，Run三种使用方式： 1.Use使用中间件配置请求管道 2.Map管道分支 3.Run管道短路 Configure方法里注入IConfiguration接口，读取 appsettings.json配置public void Configure(IApplicationBuilder app,IHostingEnvironment env,IConfiguration configuration) { if(env.IsDevelopment()) { app.UseDevelopmerExceptionPage(); } app.Run(async(context)=&gt; { //appsettings.json里面添加的key是Welcome,值为Hello World！ var welcome=configuration[&quot;Welcome&quot;]; await context.Response.WriteAsync(welcome); }); } 运行结果：Hello World！ ConfigureServices配置应用服务public void ConfigureServices(IServiceCollection services) { //服务注入 &lt;接口，实现接口的类&gt; services.AddSingleton&lt;IWelcomeService,WelcomeService&gt;(); //AddSingleton只能有WelcomeService实例 //AddTransient每请求一次方法就创建一个实例 //AddScoped 整个HTTP请求只创建一个实例 } public void Configure(IApplicationBUilder app,IHostingEnvironment env,IWelcomeService welcomeService) { if(env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.Run(async(context)=&gt; { //调用GetMessage方法 var welcome=welcomeService.GetMessage(); await context.Response.WriteAsync(welcome); }); } IWlcomeService接口及实现public interface IWelcomeService { string GetMessage(); } public class WelcomeService:IWelcomeService { public string GetMessage() { return &quot;Hello from IWelcome service!&quot;; } } 运行结果:Hello from IWelcome service!]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Asp.Net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数使用]]></title>
    <url>%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[任何一个类至少会有一个构造方法，即使不写，默认会有一个公开的无参构造方法： public class MyClass { //.. } 它的构造方法就是： public Myclass() { //.. } 当我们实例化的时候，其实调用了构造方法。 可以在构造方法上写注释，new时看注释就知道了。 ///&lt;summary&gt; ///这是类 ///&lt;/summary&gt; public class Program { ///&lt;summary&gt; ///这是构造方法 ///&lt;/summary&gt; public Program() { //.. } } 通过有参数构造方法表示必填的字段，防止某些必须的字段时默认值 举个例子，如下实体： public class User { public string FirstName {get;set;} public string LastName {get;set;} public ShowName() { var user=new User(); user.FirstName=&quot;张&quot;; user.LastName=&quot;三&quot;; user.ShowName(); //输出 张三 } } 如果少写一个的话： static void Main(string[] args) { var user=new User(); user.LastName=&quot;三&quot;; user.ShowName(); // 输出 三 } 这就引起不是我们想要的因此构造方法这样就可以避免了: public class User { public User(string firstName,string lastName) { this.FirstName=firstName; tshi.LastName=lastName; } public string FirstName {get; private set;} public string LastName {get; private set;} public string ShowName() { return FirstName+LastName; } } 这里加入了两个参数，姓和名。因此实例化这个对象时必须传入这两个参数。 var user=new User(&quot;张&quot;,&quot;三&quot;); user.ShowName(); //输出 张三 注意：set访问修饰符设置成pbulic属性可以被外面赋值,调用时就会有问题： var user=new User(&quot;张&quot;,&quot;三&quot;); user.FirstName=&quot;李&quot;; user.LastName=&quot;四&quot;; user.ShowName();//输出 李四 本文转载自 http://dotnetstar.club/c/35]]></content>
      <tags>
        <tag>C#</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架与架构设计]]></title>
    <url>%2F%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[test架构：软件体系结构通常称为架构 框架与架构共同点：提高生产效率为了解决问题都是体系化的产物·····不同点：框架是总体规划，协调单元完成工作框架是具体实施内容]]></content>
      <tags>
        <tag>基础</tag>
        <tag>架构</tag>
      </tags>
  </entry>
</search>
